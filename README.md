# Tetris for Two
#### Video Demo:  <URL HERE>
#### Description:
Tetris for a Two is a multiplayer pygame recreation of the game "Tetris," originally created by Alexey Pajitnov. This recreation is designed for two local players, where both share the oncoming pieces. The game features a “bag shuffle,” where instead of the next Tetromino being selected randomly, a bag of each different Tetromino is shuffled and then picked from. This method, commonly used in official Tetris games, prevents the player from receiving the same Tetromino more than twice in a row. The choice was also made to have both players share the oncoming Tetrominoes, adding an interesting dynamic of trying to “steal” a useful piece before the other player can get to it.

I chose to make my recreation of Tetris in pygame for a few reasons. Firstly, I am familiar with Python as much of the CS50 curriculum uses Python. Secondly, Python is relatively simple syntax-wise, meaning that I don’t have to worry about making simple syntax errors and can instead focus on functionality. Finally, when it comes to game development, Pygame doesn’t have as much built-in functionality as game engines such as Unity, Unreal Engine, and Godot. This allows me to focus more on practicing my coding abilities and less on using built-in engine features.

There are two classes in the code: one for the Player, which was added when I turned the game into a local multiplayer game, and a Tetromino class. This is my first time using classes, and while I struggled a bit learning them through YouTube tutorials, I felt that they were necessary. Tetrominoes are constantly being created, so the Tetromino can call `self.__init__` on itself once it locks in, bringing the “playing Tetromino” back to the top with a new set of attributes. I also wanted to have classes for players because when I implemented a second player, it was a convenient way of not having to rewrite all the code I had already written for the first player.

Tetris For Two uses a 2D list internally to handle the playing grid. Each piece is also its own 2D list, and a dictionary at the beginning associates every Tetromino name with a color and shape. The first dimension of the list is the y value, where 0 is the top, and the second dimension of the list is the x value, where 0 is the left. Tetrominoes aren’t added to the internal playing grid until they have been “locked in” (either hard dropped or reached the bottom). Initially, I had each falling tile be separate and in the playing grid as they fell, but I changed this after much headache because it made it very difficult to move four tiles as a Tetromino without them catching on each other since they kept “colliding” with their fellow tile.

The internal playing grid and playing Tetrominoes are rendered separately, however they are rendered the same way. A for loop enumerates through either the playing grid or Tetromino 2d list, and then calls on `pygame.draw.rect` with the indexes multiplied by 25 to render each tile as a 25 by 25 rectangle of the appropriate color.

Tetrominoes have an internal position and shape, as well as a function that checks if they are currently in a valid position. The valid position function is the most important function for gravity, movement, and hard dropping, and it will return False if the position provided is not a valid position for the Tetromino to be in in the playing grid (which is usually if there is collision or if the position it’s trying is outside of the playing grid). The movement function will reverse the attempted movement if the position is not valid, meanwhile the gravity and hard drop functions will lock the Tetromino into the playing grid and move on to the next playing Tetromino. The way the hard drop function (called “slam” in the code) works is basically just like the gravity function, except it keeps adding to the y coordinate of the Tetromino until it gets an invalid position.

The gravity of the blocks operates on a tick-based system, where an interval is set in the code, and every time the game time is divisible by that interval, it calls on the Tetromino’s gravity function. This setup also makes it very easy to speed up time as the player clears more lines since you can just decrease the interval, which will make ticks come by faster.
This project was my first time completing a coding project to a point of satisfaction, and I feel that I learned a lot with it including overcoming roadblocks with programming, how one often just has to redo a feature a different way (like how I tried implementing Tetrominoes) to get it to work, and how valuable the ability to learn new things on your own is.
